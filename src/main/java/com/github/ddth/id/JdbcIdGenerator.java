package com.github.ddth.id;

import java.sql.Connection;
import java.sql.SQLException;
import java.text.MessageFormat;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;

import javax.sql.DataSource;

import org.apache.commons.dbcp2.BasicDataSource;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.springframework.dao.DeadlockLoserDataAccessException;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.SingleConnectionDataSource;

import com.github.ddth.id.utils.IdException;

/**
 * This id generator utilizes JDBC to generate serial IDs.
 * 
 * <p>
 * Persistency: IDs generated by this id-generator are persistent (assuming the
 * database backend runs in persistent mode).
 * </p>
 * 
 * @author Thanh Nguyen <btnguyen2k@gmail.com>
 * @since 0.3.0
 */
public class JdbcIdGenerator extends SerialIdGenerator {

    /**
     * Helper method to obtain {@link JdbcIdGenerator}.
     * 
     * @param zkConnString
     * @return
     */
    public static JdbcIdGenerator getInstance(final String jdbcDriver, final String jdbcUrl,
            final String jdbcUser, final String jdbcPassword, final String jdbcTableName) {
        try {
            final HashCodeBuilder hcb = new HashCodeBuilder(19, 81);
            hcb.append(jdbcDriver).append(jdbcUrl).append(jdbcUrl).append(jdbcPassword)
                    .append(jdbcTableName);
            final String hashKey = String.valueOf(hcb.hashCode()) + "-" + jdbcUrl + "-" + jdbcUser
                    + "-" + jdbcTableName;
            JdbcIdGenerator idGen = (JdbcIdGenerator) idGenerators.get(hashKey,
                    new Callable<SerialIdGenerator>() {
                        @Override
                        public SerialIdGenerator call() throws Exception {
                            // build datasource
                            BasicDataSource ds = new BasicDataSource();
                            ds.setDriverClassName(jdbcDriver);
                            ds.setUrl(jdbcUrl);
                            ds.setUsername(jdbcUser);
                            ds.setPassword(jdbcPassword);
                            JdbcIdGenerator idGen = new JdbcIdGenerator();
                            idGen.setTableName(jdbcTableName).setDataSource(ds).init();
                            return idGen;
                        }
                    });
            return idGen;
        } catch (ExecutionException e) {
            return null;
        }
    }

    private DataSource dataSource;
    private String tableName;
    private String sqlInsert, sqlUpdate, sqlSelect;
    private String colName = "id_name";
    private String colValue = "id_value";

    public DataSource getDataSource() {
        return dataSource;
    }

    public JdbcIdGenerator setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
        return this;
    }

    public String getTableName() {
        return tableName;
    }

    public JdbcIdGenerator setTableName(String tableName) {
        this.tableName = tableName;
        return this;
    }

    private Connection connection() throws SQLException {
        return dataSource.getConnection();
    }

    private JdbcTemplate jdbcTemplate(Connection conn) {
        return new JdbcTemplate(new SingleConnectionDataSource(conn, true));
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JdbcIdGenerator init() {
        super.init();

        sqlInsert = MessageFormat.format("INSERT INTO {0} ({1}, {2}) VALUES (?, 0)", tableName,
                colName, colValue);
        sqlUpdate = MessageFormat.format("UPDATE {0} SET {2}={2}+1 WHERE {1}=?", tableName,
                colName, colValue);
        sqlSelect = MessageFormat.format("SELECT {2} FROM {0} WHERE {1}=?", tableName, colName,
                colValue);

        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void destroy() {
        super.destroy();
    }

    private boolean _update(final JdbcTemplate jdbcTemplate, final String namespace,
            final int numRetries, final int maxRetries) {
        try {
            int status = jdbcTemplate.update(sqlUpdate, namespace);
            return status > 0;
        } catch (DeadlockLoserDataAccessException dle) {
            if (numRetries > maxRetries) {
                throw dle;
            } else {
                return _update(jdbcTemplate, namespace, numRetries + 1, maxRetries);
            }
        }
    }

    private final static Long ZERO = new Long(0);

    private Long _select(final JdbcTemplate jdbcTemplate, final String namespace,
            final int numRetries, final int maxRetries) {
        try {
            Long result = jdbcTemplate.queryForObject(sqlSelect, Long.class, namespace);
            return result;
        } catch (EmptyResultDataAccessException e) {
            return ZERO;
        } catch (DeadlockLoserDataAccessException dle) {
            if (numRetries > maxRetries) {
                throw dle;
            } else {
                return _select(jdbcTemplate, namespace, numRetries + 1, maxRetries);
            }
        }
    }

    private boolean _insert(JdbcTemplate jdbcTemplate, final String namespace,
            final int numRetries, final int maxRetries) {
        try {
            int status = jdbcTemplate.update(sqlInsert, namespace);
            return status > 0;
        } catch (DeadlockLoserDataAccessException dle) {
            if (numRetries > maxRetries) {
                throw dle;
            } else {
                return _insert(jdbcTemplate, namespace, numRetries + 1, maxRetries);
            }
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long nextId(String namespace) {
        try {
            Connection conn = connection();
            try {
                conn.setAutoCommit(false);
                conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
                JdbcTemplate jdbcTemplate = jdbcTemplate(conn);
                if (!_update(jdbcTemplate, namespace, 0, 3)) {
                    _insert(jdbcTemplate, namespace, 0, 3);
                    _update(jdbcTemplate, namespace, 0, 3);
                }
                Long result = _select(jdbcTemplate, namespace, 0, 3);
                conn.commit();
                return result != null ? result.longValue() : 0;
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            } finally {
                conn.close();
            }
        } catch (SQLException e) {
            throw new IdException.OperationFailedException(e);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long currentId(String namespace) {
        try {
            Connection conn = connection();
            try {
                JdbcTemplate jdbcTemplate = jdbcTemplate(conn);
                Long result = _select(jdbcTemplate, namespace, 0, 3);
                return result != null ? result.longValue() : 0;
            } finally {
                conn.close();
            }
        } catch (SQLException e) {
            throw new IdException.OperationFailedException(e);
        }
    }
}