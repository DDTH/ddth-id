package com.github.ddth.id.cassandra;

import java.io.IOException;
import java.text.MessageFormat;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.datastax.driver.core.ConsistencyLevel;
import com.datastax.driver.core.PreparedStatement;
import com.datastax.driver.core.ResultSet;
import com.datastax.driver.core.Row;
import com.datastax.driver.core.Session;
import com.datastax.driver.core.exceptions.QueryConsistencyException;
import com.datastax.driver.core.exceptions.WriteTimeoutException;
import com.datastax.driver.core.policies.ConstantSpeculativeExecutionPolicy;
import com.datastax.driver.core.policies.DefaultRetryPolicy;
import com.datastax.driver.core.policies.LoggingRetryPolicy;
import com.github.ddth.cql.CqlUtils;
import com.github.ddth.cql.SessionManager;
import com.github.ddth.id.SerialIdGenerator;
import com.github.ddth.id.utils.IdException;

/**
 * This id generator utilizes Cassandra to generate serial IDs.
 * 
 * <p>
 * Persistency: IDs generated by this id-generator are persistent (backed by
 * Cassandra).
 * </p>
 * 
 * @author Thanh Nguyen <btnguyen2k@gmail.com>
 * @since 0.5.0
 */
public class CassandraIdGenerator extends SerialIdGenerator {

    private static Logger LOGGER = LoggerFactory.getLogger(CassandraIdGenerator.class);

    private SessionManager sessionManager;
    private boolean myOwnSessionManager = true;
    private String hostsAndPorts, keyspace, user, password;
    private String tableName;
    private String colName = "id_name";
    private String colValue = "id_value";
    private ConsistencyLevel consistencyLevelGetValue = ConsistencyLevel.LOCAL_QUORUM;
    private ConsistencyLevel consistencyLevelGetForSet = ConsistencyLevel.LOCAL_ONE;
    private ConsistencyLevel consistencyLevelSetValue = ConsistencyLevel.LOCAL_QUORUM;
    private PreparedStatement stmGetValue, stmInsertNew, stmSetExisting, stmUpdateExisting;

    public SessionManager getSessionManager() {
        return sessionManager;
    }

    public CassandraIdGenerator setSessionManager(SessionManager sessionManager) {
        if (this.sessionManager != null && myOwnSessionManager) {
            try {
                sessionManager.close();
            } catch (IOException e) {
                LOGGER.warn(e.getMessage(), e);
            }
        }
        this.sessionManager = sessionManager;
        myOwnSessionManager = false;
        return this;
    }

    /**
     * 
     * @return
     */
    public String getHostsAndPorts() {
        return this.hostsAndPorts;
    }

    /**
     * 
     * @param hostsAndPorts
     * @return
     */
    public CassandraIdGenerator setHostsAndPorts(String hostsAndPorts) {
        this.hostsAndPorts = hostsAndPorts;
        return this;
    }

    /**
     * 
     * @return
     */
    public String getKeyspace() {
        return this.keyspace;
    }

    /**
     * 
     * @param keyspace
     * @return
     */
    public CassandraIdGenerator setKeyspace(String keyspace) {
        this.keyspace = keyspace;
        return this;
    }

    /**
     * 
     * @return
     */
    public String getUser() {
        return this.user;
    }

    /**
     * 
     * @param user
     * @return
     */
    public CassandraIdGenerator setUser(String user) {
        this.user = user;
        return this;
    }

    /**
     * 
     * @return
     */
    public String getPassword() {
        return this.password;
    }

    /**
     * 
     * @param password
     * @return
     */
    public CassandraIdGenerator setPassword(String password) {
        this.password = password;
        return this;
    }

    public String getTableName() {
        return tableName;
    }

    public CassandraIdGenerator setTableName(String tableName) {
        this.tableName = tableName;
        return this;
    }

    public String getTableColumnName() {
        return colName;
    }

    public CassandraIdGenerator setTableColumnName(String colName) {
        this.colName = colName;
        return this;
    }

    public String getTableColumnValue() {
        return colValue;
    }

    public CassandraIdGenerator setTableColumnValue(String colValue) {
        this.colValue = colValue;
        return this;
    }

    public ConsistencyLevel getConsistencyLevelGetValue() {
        return consistencyLevelGetValue;
    }

    public CassandraIdGenerator setConsistencyLevelGetValue(ConsistencyLevel consistencyLevel) {
        this.consistencyLevelGetValue = consistencyLevel;
        return this;
    }

    public ConsistencyLevel getConsistencyLevelGetForSet() {
        return consistencyLevelGetForSet;
    }

    public CassandraIdGenerator setConsistencyLevelGetForSet(ConsistencyLevel consistencyLevel) {
        this.consistencyLevelGetForSet = consistencyLevel;
        return this;
    }

    public ConsistencyLevel getConsistencyLevelSetValue() {
        return consistencyLevelSetValue;
    }

    public CassandraIdGenerator setConsistencyLevelSetValue(ConsistencyLevel consistencyLevel) {
        this.consistencyLevelSetValue = consistencyLevel;
        return this;
    }

    protected Session getSession() {
        try {
            return sessionManager.getSession(hostsAndPorts, user, password, keyspace);
        } catch (Exception e) {
            throw e instanceof IdException ? (IdException) e : new IdException(e);
        }
    }

    /**
     * Creates a {@link SessionManager} instance. Sub-class my override this
     * method to customized its own {@link SessionManager}.
     * 
     * @return
     */
    protected SessionManager createSessionManager() {
        SessionManager sm = new SessionManager();

        // sm.setRetryPolicy(new
        // LoggingRetryPolicy(DowngradingConsistencyRetryPolicy.INSTANCE));
        sm.setRetryPolicy(new LoggingRetryPolicy(DefaultRetryPolicy.INSTANCE));
        sm.setSpeculativeExecutionPolicy(new ConstantSpeculativeExecutionPolicy(10000, 3));

        sm.init();
        return sm;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CassandraIdGenerator init() {
        if (sessionManager == null) {
            sessionManager = createSessionManager();
            myOwnSessionManager = true;
        }

        super.init();

        Session session = getSession();
        String cql;

        cql = "SELECT {0} FROM {1} WHERE {2}=?";
        stmGetValue = CqlUtils.prepareStatement(session,
                MessageFormat.format(cql, colValue, tableName, colName));

        cql = "INSERT INTO {0} ({1}, {2}) VALUES (?, ?) IF NOT EXISTS";
        stmInsertNew = CqlUtils.prepareStatement(session,
                MessageFormat.format(cql, tableName, colName, colValue));
        stmInsertNew.setIdempotent(true);
        cql = "UPDATE {0} SET {1}=? WHERE {2}=? IF EXISTS";
        stmSetExisting = CqlUtils.prepareStatement(session,
                MessageFormat.format(cql, tableName, colValue, colName));
        stmSetExisting.setIdempotent(true);

        cql = "UPDATE {0} SET {1}=? WHERE {2}=? IF {3}=?";
        stmUpdateExisting = CqlUtils.prepareStatement(session,
                MessageFormat.format(cql, tableName, colValue, colName, colValue));
        stmUpdateExisting.setIdempotent(true);

        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void destroy() {
        try {
            super.destroy();
        } catch (Exception e) {
            LOGGER.warn(e.getMessage(), e);
        }

        if (myOwnSessionManager && sessionManager != null) {
            try {
                sessionManager.destroy();
            } catch (Exception e) {
                LOGGER.warn(e.getMessage(), e);
            } finally {
                sessionManager = null;
            }
        }
    }

    private boolean _setValue(Session session, String namespace, long newValue, long currentValue) {
        ResultSet result;
        if (currentValue < 0) {
            result = CqlUtils.execute(session, stmInsertNew, consistencyLevelSetValue, namespace,
                    newValue);
        } else {
            result = CqlUtils.execute(session, stmUpdateExisting, consistencyLevelSetValue,
                    newValue, namespace, currentValue);
        }
        return result != null ? result.wasApplied() : false;
    }

    private long _nextId(Session session, String namespace, boolean ignoreTimeout) {
        try {
            while (true) {
                Row row = CqlUtils.executeOne(session, stmGetValue, consistencyLevelGetForSet,
                        namespace);
                long currentValue = row != null ? row.getLong(colValue) : -1;
                if (currentValue < 0) {
                    try {
                        if (_setValue(session, namespace, 1, currentValue)) {
                            return 1;
                        }
                    } catch (WriteTimeoutException e) {
                        if (ignoreTimeout && e.getReceivedAcknowledgements() > 0) {
                            return 1;
                        }
                    }
                } else {
                    try {
                        if (_setValue(session, namespace, currentValue + 1, currentValue)) {
                            return currentValue + 1;
                        }
                    } catch (WriteTimeoutException e) {
                        if (ignoreTimeout && e.getReceivedAcknowledgements() > 0) {
                            return currentValue + 1;
                        }
                    }
                }
            }
        } catch (QueryConsistencyException e) {
            if (ignoreTimeout) {
                return -2;
            } else {
                throw new IdException.OperationTimeoutException(e);
            }
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long nextId(String namespace) {
        return _nextId(getSession(), namespace, false);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long nextIdWithRetries(String namespace, long timeout, TimeUnit timeoutUnit) {
        Session session = getSession();
        long timestamp = System.currentTimeMillis();
        long timeoutMs = timeoutUnit.toMillis(timeout);
        long nextId = _nextId(session, namespace, true);
        while (nextId < 0 && System.currentTimeMillis() - timestamp <= timeoutMs) {
            nextId = _nextId(session, namespace, true);
        }
        return nextId;
    }

    /**
     * Fetches namespace's current value.
     * 
     * @param session
     * @param namespace
     * @return current id value, or {@code -1} if namespace does not exist, or
     *         {@code -2} if timed-out
     */
    private long _currentId(Session session, String namespace, boolean ignoreTimeout) {
        try {
            Row row = CqlUtils.executeOne(session, stmGetValue, consistencyLevelGetValue,
                    namespace);
            return row != null ? row.getLong(colValue) : -1;
        } catch (QueryConsistencyException e) {
            if (ignoreTimeout) {
                return -2;
            } else {
                throw e;
            }
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long currentId(String namespace) {
        try {
            long result = _currentId(getSession(), namespace, false);
            return result >= 0 ? result : (result == -1 ? 0 : -2);
        } catch (QueryConsistencyException e) {
            throw new IdException.OperationTimeoutException(e);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long currentIdWithRetries(String namespace, long timeout, TimeUnit timeoutUnit) {
        Session session = getSession();
        long timestamp = System.currentTimeMillis();
        long timeoutMs = timeoutUnit.toMillis(timeout);
        long currentId = _currentId(session, namespace, true);
        while (currentId < -1 && System.currentTimeMillis() - timestamp <= timeoutMs) {
            currentId = _currentId(session, namespace, true);
        }
        return currentId >= 0 ? currentId : (currentId == -1 ? 0 : -2);
    }

    private boolean _setValue(Session session, String namespace, long newValue,
            boolean ignoreTimeout) {
        try {
            ResultSet result;
            result = CqlUtils.execute(session, stmSetExisting, consistencyLevelSetValue, newValue,
                    namespace);
            if (result == null || !result.wasApplied()) {
                result = CqlUtils.execute(session, stmInsertNew, consistencyLevelSetValue,
                        namespace, newValue);
            }
            return result != null ? result.wasApplied() : false;
        } catch (QueryConsistencyException e) {
            if (ignoreTimeout) {
                return false;
            } else {
                throw e;
            }
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean setValue(String namespace, long value) {
        if (value < 0) {
            throw new IdException("Id value must be greater or equal to 0!");
        }
        try {
            return _setValue(getSession(), namespace, value, false);
        } catch (QueryConsistencyException e) {
            throw new IdException.OperationTimeoutException(e);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean setValueWithRetries(String namespace, long value, long timeout,
            TimeUnit timeoutUnit) {
        Session session = getSession();
        long timestamp = System.currentTimeMillis();
        long timeoutMs = timeoutUnit.toMillis(timeout);
        boolean result = _setValue(session, namespace, value, true);
        while (!result && System.currentTimeMillis() - timestamp <= timeoutMs) {
            result = _setValue(session, namespace, value, true);
        }
        return result;
    }
}